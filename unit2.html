<!DOCTYPE html>
<html>
	<head>
		<title>Blox</title>
		<link rel="stylesheet" type="text/css" href="css/index.css">
	</head>

	<body>
		<canvas width="" height="700"></canvas>

		<script type="text/javascript" src="js/canvas.js"></script>


		<script type="text/javascript">
			// add this to the canvas code...
			var canvasWidth = window.innerWidth;
			canvas.width = canvasWidth;


		// canvas
			// var canvas = document.getElementsByTagName('canvas')[0];
			// var context = canvas.getContext('2d');
		//

		// GLOBALS
			var enemyBlockAmount = 20;
			// blocks all - array - contains all block in the application
			// used to loop through all the blocks and perform 
			// necessary destruct and creation methods.
			var blocksAll = [];

		//

		// objects

			/* Top level block.. like an abstract class...
			* c'tor
			* x and y axis (int)
			* width and height (int)
			* direction x and y (floats)

			* function -- check block collision
			* function -- change direction
			* -function -- draw
			* function -- check wall collision
			* function -- tick
			* -function -- destructor
			*/
			function Block(x, y, width, height, dx, dy){
				this.x = x || 0;
				this.y = y || 0;
				this.width = width || 0;
				this.height = height || 0;
				this.dx = dx || 0;
				this.dy = dy || 0;

				this.draw = function(){
					context.fillStyle = 'red';
					context.fillRect(this.x, this.y, 
									this.width, this.height);
				}
				// remove from the array which tracks all active blocks
				this.destruct = function(blocksAll){
					for(var i = 0; i < blocksAll.length; i++) {
						if(this === blocksAll[i]) {
							blocksAll.splice(i, 1);
						}
					}
				}
				//
				// check if block is colliding against wall.
				this.wallCollide = function(){
					//console.log(this.dx);
					if (this.x + this.width >= canvas.width && this.dx < 0 ||
						this.x <= 0 && this.dx > 0){
						this.dx = this.dx * -1;
					}
					if (this.y + this.height >= canvas.height && this.dy < 0 ||
						this.y <= 0 && this.dy > 0){
						this.dy = this.dy * -1;
					}
				}
				//
				// function to change direction,
				// used in an abstract sort of way
				// since children will have different implementations of it.
				this.changeDirection = function(){
					// abstract method.
				}
				// if this block has collided with another block
				// change the width and height parameters
				this.collision = function(blocksAll){
					for (var i = 0; i < blocksAll.length; i++) {
						if (blocksAll[i] !== this){
							if(isCollide(this, blocksAll[i])){
								if(this.width < blocksAll[i].width){
									this.width -= 2;
									this.height -= 2;
								}else if(this.width > blocksAll[i].width){
									this.width += 2;
									this.height += 2;
								}
							}
						}
					};
				}
				//
				// works with the main application loop
				this.tick = function(){
					this.width <= 0 ? this.destruct(blocksAll) : false;
					this.wallCollide();
					this.x -= this.dx;
					this.y -= this.dy;
					this.collision(blocksAll);
					this.draw();
				}
				//
				// add block to blocksAll array
				blocksAll.push(this);
			}
			//
			
			/* children of block
			* using apply for inheritance and pass arguments
			*/
			// AI block
			function AIblock(x, y, width, height, dx, dy){
				Block.apply(this, arguments);
				this.incrementer = 0;
				this.aiMotionLength = Math.floor(Math.random() * 500);
				// generate random directions.
				this.changeDirection = function(){
					var xRand = Math.round(Math.random());
					var yRand = Math.round(Math.random());
					this.dx = (xRand === 0) ? -1 * Math.random() : Math.random();
					this.dy = (yRand === 0) ? -1 * Math.random() : Math.random();
					this.incrementer = 0;
					this.aiMotionLength = Math.floor(Math.random() * 500);
				}
				// modifing the parents tick method
				// so the ai can change direction randomly...
				this.tick = function(){
					this.width <= 0 ? this.destruct(blocksAll) : false;
					this.wallCollide();
					this.x -= this.dx;
					this.y -= this.dy;
					this.collision(blocksAll);
					this.draw();
					this.incrementer++;
					(this.incrementer >= this.aiMotionLength) ? this.changeDirection() : '';
				}
			}

			// The players block
			function Pblock(x, y, width, height, dx, dy){
				Block.apply(this, arguments);
				this.draw = function(){
					context.fillStyle = 'blue';
					context.fillRect(this.x, this.y, 
					          			this.width, this.height);
				}
				var block = this;
				// player block changes direction on
				// mouse click
				this.changeDirection = function(event){
					//console.log(block);
					var mouseX = new Number();
					var mouseY = new Number();
					if (event.x != undefined && event.y != undefined){
						mouseX = event.x;
						mouseY = event.y;
					}else{
						mouseX = event.clientX + document.body.scrollLeft +
								document.documentElement.scrollLeft;
						mouseY = event.clientY + document.body.scrollTop +
								document.documentElement.scrollTop;
					}
					mouseX -= canvas.offsetLeft;
					mouseY -= canvas.offsetTop;
					var squareCenterX = block.x + block.width/2;
					var squareCenterY = block.y + block.height/2;
					var d = 1;

					var mag = Math.sqrt(Math.pow(mouseX - squareCenterX, 2)
						 + Math.pow(mouseY - squareCenterY, 2));

					block.dx = d * (mouseX - squareCenterX) / mag;
					block.dy = d * (mouseY - squareCenterY) / mag;
					console.log(block.dx);
				}
			}
		//
			
		// helper functions
			// check if two blocks have collided.
			function isCollide(a, b) {
				return !(
					((a.y + a.height) < (b.y)) || 
					(a.y > (b.y + b.height)) ||
					((a.x + a.width) < b.x) || (
					a.x > (b.x + b.width))
				);
			}

			// clears the canvas
			function clear(canvas, context){
				context.clearRect(0, 0, canvas.width, canvas.height);
			}

			// generate a random number between 2 numbers
			function randomFromInterval(from,to){
				return Math.floor(Math.random()*(to-from+1)+from);
			}

			// Create enemy blocks based on 
			// the enemy amount, give them random size
			// and positioning.
			function createEnemyBlocks(enemyBlockAmount){
				for (var i = 0; i < enemyBlockAmount; i++) {
					var posX = randomFromInterval(0, canvas.width);
					var posY = randomFromInterval(0, canvas.height);
					var heightWidth = randomFromInterval(0, 70);
					var iniDx = (Math.floor(Math.random()) == 0) ? Math.random() : Math.random() * -1;
					var iniDy = (Math.floor(Math.random()) == 0) ? Math.random() * -1 : Math.random();
					this.block = new AIblock(posX, posY, 
											heightWidth, heightWidth, 
											iniDx, iniDy);
				};
			}

			// generate a random number between 2 numbers
			function randomFromInterval(from,to){
				return Math.floor(Math.random()*(to-from+1)+from);
			}

			// clear canvas run each blocks tick function.
			function loop(canvas, context, blocks, mod){
				clear(canvas, context);
				for( var i=0; i<blocks.length; i++){
					blocks[i].tick();
				}
			}
		//

		// initialize the application
			(function init(){
				var canvas = document.getElementsByTagName('canvas')[0];
				var context = canvas.getContext('2d');
				var player = new Pblock(50, 50, 50, 50);
				canvas.addEventListener('click', player.changeDirection);
				createEnemyBlocks(enemyBlockAmount);
				var k = 0;
				setInterval(function(){
					// set up ai intelligence... if its an ai...
					var aiMotionLength = Math.floor(Math.random() * 500);
					var mod = k%aiMotionLength;
					//
					loop(canvas, context, blocksAll, mod);
					k++;

				}, 10);
			})();
		//

		</script>
	</body>

<html>