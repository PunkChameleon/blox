<!DOCTYPE html>
<html>
	<head>
		<title>Blox</title>
		<link rel="stylesheet" type="text/css" href="css/index.css">
	</head>

	<body>
		<canvas width="700" height="700"></canvas>

		<script type="text/javascript" src="js/canvas.js"></script>


		<script type="text/javascript">
			// return where the mouse was clicked
			function trackMouse(event){
				var mouseX = new Number();
				var mouseY = new Number();
				if (event.x != undefined && event.y != undefined){
					mouseX = event.x;
					mouseY = event.y;
				}else{
					mouseX = event.clientX + document.body.scrollLeft +
							document.documentElement.scrollLeft;
					mouseY = event.clientY + document.body.scrollTop +
							document.documentElement.scrollTop;
				}

				mouseX -= canvas.offsetLeft;
				mouseY -= canvas.offsetTop;
				return [mouseX, mouseY];
			}

			function calculateMovement(mousePos){
				var squareCenterX = x + width/2;
				var squareCenterY = y + height/2;
				var d = 1;
				var mag = Math.sqrt(Math.pow(mousePos[0] - squareCenterX, 2)
						 + Math.pow(mousePos[1] - squareCenterY, 2));

				var P3x = d * (mousePos[0] - squareCenterX) / mag;
				var P3y = d * (mousePos[1] - squareCenterY) / mag;
				return [P3x, P3y];
			}

			function Block(context, x, y, width, height){
				this.x = x||0;
				this.y = y||0;
				this.width = width||0;
				this.height = height||0;
				this.dx = 0;
				this.dy = 0;
				var block = this;
				this.draw = function(){
					if (this.width > 0){
						context.fillRect(this.x, this.y, this.width, this.height);
					}
				}
				this.changeDirection = function(event){
					// first, get the mouse click position
					var mouseX = new Number();
					var mouseY = new Number();
					if (event.x != undefined && event.y != undefined){
						mouseX = event.x;
						mouseY = event.y;
					}else{
						mouseX = event.clientX + document.body.scrollLeft +
								document.documentElement.scrollLeft;
						mouseY = event.clientY + document.body.scrollTop +
								document.documentElement.scrollTop;
					}
					mouseX -= canvas.offsetLeft;
					mouseY -= canvas.offsetTop;
					// use the mouse position to change
					// the direction variables
					var squareCenterX = block.x + block.width/2;
					var squareCenterY = block.y + block.height/2;
					var d = 1;

					var mag = Math.sqrt(Math.pow(mouseX - squareCenterX, 2)
						 + Math.pow(mouseY - squareCenterY, 2));

					block.dx = d * (mouseX - squareCenterX) / mag;
					block.dy = d * (mouseY - squareCenterY) / mag;
				}
				this.tick = function(isAi){
					// collision detection for walls
					if (isAi === false){
						// for the player
						this.dx = (this.x + this.width >= canvas.width || this.x <= 0 ) ? 
									this.dx * -1 : this.dx;
						this.dy = (this.y + this.height >= canvas.height || this.y <= 0 ) ? 
									this.dy * -1 : this.dy;
					}else{
						// for the ai,
						// first, random positive or negative x y values
						var xRand = Math.round(Math.random());
						var yRand = Math.round(Math.random());
						// get the actual xy values
						this.dx = (xRand === 0) ? -1 * Math.random() : Math.random();
						this.dy = (yRand === 0) ? -1 * Math.random() : Math.random();
					}
					this.x -= this.dx;
					this.y -= this.dy;
					this.collision(blocksAll);
					this.draw();
				}
				// keeping track of all the blocks via array.
				blocksAll.push(this);
				this.collision = function(blocksAll){
					for (var i = 0; i < blocksAll.length; i++) {
						if (blocksAll[i] !== this){
							if(isCollide(this, blocksAll[i])){
								if(this.width < blocksAll[i].width){
									this.width -= 2;
									this.height -= 2;
								}else if(this.width > blocksAll[i].width){
									this.width += 2;
									this.height += 2;
								}
							}
						}
					};
				}
			}
			// array to keep track of all the blocks
			var blocksAll = [];




			function isCollide(a, b) {
				return !(
					((a.y + a.height) < (b.y)) || 
					(a.y > (b.y + b.height)) ||
					((a.x + a.width) < b.x) || (
					a.x > (b.x + b.width))
				);
			}
			/**
			* Check if this block is colloding with other blocks.
			* @ param, others: array, this is an array of the other blocks
			* There has to be a better algorithm for this elsewhere?
			* recursion is the answer here....
			**/
			checkCollosion = function(others){
				// may be buggy because we're using others here,
				// and others is in the next scope up, they may be 
				// competing in scope?
				var subject = others.pop();
				for (var i=0; i<others.length; i++){
					if(isCollide(subject, others[i])){
						// console.log('hit');
						// // collosion is true, the biggest eats the smallest
						// console.log('subj: ' + subject.width);
						// console.log('oth: ' + others[i].width);
						if(subject.width < others[i].width){
							console.log('eat');
							others.width = others.width + 10;
							subject.width = subject.width - 10;
						}
					}
				}
			}

			function clear(canvas, context){
				context.clearRect(0, 0, 700, 700);
			}

			function loop(canvas, context, blocks, mod){
				clear(canvas, context);
				for( var i=0; i<blocks.length; i++){
					// check if blocks are colliding...
					if (i != 0 && mod == 0){
						blocks[i].tick(true);
					}else{
						blocks[i].tick(false);
					}
				}
			}

			(function init(){
				var canvas = document.getElementsByTagName('canvas')[0];
				var context = canvas.getContext('2d');
				block1 = new Block(context, 50, 50, 50, 50);
				block2 = new Block(context, 300, 300, 48, 48);
				block3 = new Block(context, 500, 500, 47, 47);
				canvas.addEventListener('click',block1.changeDirection);


				var blocks = [block1, block2, block3];
				var k = 0;
				setInterval(function(){
					// set up ai intelligence... if its an ai...
					var aiMotionLength = Math.floor(Math.random() * 500);
					var mod = k%aiMotionLength;
					//
					// var others = [block1, block2, block3];
					// checkCollosion(others);
					loop(canvas, context, blocks, mod);


					k++;

				}, 10);

			})();

		</script>
	</body>

<html>